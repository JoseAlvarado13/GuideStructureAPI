# GuideStructureAPI
****************************************************************************************************************************************************************************************************************************************************************************
Español
****************************************************************************************************************************************************************************************************************************************************************************
Mi nombre es José Andrés Alvarado Matamoros, y cuento con una experiencia laboral de aproximadamente 5 a 6 años como Software Developer. Actualmente, soy estudiante avanzado de la carrera de Ingeniería en Sistemas en la Universidad Fidélitas. Este proyecto ha sido desarrollado utilizando la tecnología ASP.NET Core Web API con el Framework .NET 6. Representa una guía que he comenzado a desarrollar en el lenguaje de programación C# con el objetivo de estandarizar estructuras de programación en futuros proyectos, tomando en cuenta principios como responsabilidad única, reutilización de código, estandarización de clases mediante nomenclaturas y la utilización de un modelo en capas bien definido.

A lo largo de este documento, se explicará detalladamente cada una de las capas y su finalidad, además de comentar sobre las clases, métodos y algunas propiedades.

Sin más preámbulo, el proyecto se encuentra dividido en las siguientes capas de programación:

A) BusinessLogic: Esta capa es responsable de llevar a cabo todas las funciones relacionadas con la lógica del negocio que la empresa necesita. Es importante destacar que las clases actuales y futuras deben ser creadas bajo la siguiente estructura de nomenclatura: NombreDeLaClase + Nomenclatura BL. Por ejemplo, si deseamos crear una clase llamada "Inventario", siguiendo esta convención la clase deberá llamarse "InventarioBL" utilizando PascalCase. Es relevante señalar que los únicos nombres de métodos válidos en nuestras clases deben ser representativos, y para estandarizar esto, se deben definir nombres como "Get", "Save", "Delete", "Update" y, en casos excepcionales, "Process" para aquellos métodos que impliquen un flujo que involucre uno o más métodos básicos. Otro punto a considerar es que, en esta capa de negocio, debemos gestionar las excepciones de código. No se deben encontrar definiciones de "try-catch" en ninguna otra clase.

B) BusinessLogicInterface: Esta capa es la encargada de crear las interfaces en programación, lo cual es esencial para organizar y estructurar el código. Las interfaces actúan como un contrato que define los métodos que debe implementar una clase, asegurando que el sistema se comporte de manera consistente. Además, proporcionan flexibilidad, permitiendo cambiar o agregar funcionalidades sin afectar el resto del sistema. Facilitan el trabajo en equipo al permitir que los desarrolladores trabajen en diferentes partes del proyecto sin depender de los detalles internos. En resumen, las interfaces son clave para tener un código más limpio, fácil de mantener y adaptable. La nomenclatura debe seguir la misma estructura que la capa BusinessLogic, pero con la diferencia de que su nombre debe comenzar con una "I" mayúscula, por ejemplo, "IInventarioBL". Es importante recalcar que, en esta capa, no se debe desarrollar ninguna lógica de negocio, sino únicamente el esqueleto que las clases específicas en la capa BusinessLogic utilizarán.

C) DataAccess: Esta capa es la encargada de realizar la lógica de acceso a datos, como la interacción con bases de datos u otros gestores de datos. Es importante recalcar que no debe desarrollarse ninguna lógica de negocio en esta capa; únicamente se debe manejar la manipulación de la base de datos, ya sea mediante LINQ o Entity Framework. En cuanto a la nomenclatura, debe seguir la misma estructura que la capa anterior, utilizando el sufijo "DA". Siguiendo el ejemplo de "Inventario", la clase debería llamarse "InventarioDA", siempre manteniendo el formato PascalCase. En esta capa tampoco deben encontrarse definiciones de "try-catch", y, al igual que en las otras capas, se debe seguir la misma regla para los nombres de los métodos, utilizando "Get", "Save", "Update", "Delete", y en caso necesario, "Process" para métodos que involucren un flujo de varios métodos básicos.

D) DataAccessInterfaces: Esta capa se encarga de definir las interfaces correspondientes para el acceso a datos. Al igual que en la capa de interfaces de negocio, las interfaces en esta capa actúan como contratos que establecen qué métodos deben implementar las clases que interactúan con la base de datos. Al igual que en la capa anterior, se debe asegurar que en esta capa no se escriba ninguna lógica de negocio, solo las interfaces necesarias para que las clases de acceso a datos en la capa "DataAccess" puedan implementar su funcionalidad correctamente.

E) Entities: Esta clase contiene las diferentes entidades del proyecto que hacen referencia a los objetos del sistema. Aquí se deben definir únicamente las entidades, sus métodos "Get" y "Set", así como el tipo de dato correspondiente. Es importante señalar que la nomenclatura para estas clases sigue el patrón "NombreClaseDTO". Por ejemplo, si estamos trabajando con la entidad "Inventario", la clase se llamará "InventarioDTO". En esta clase, se busca representar las estructuras de datos que serán manipuladas por las demás capas.

F) EntitiesInterfaces: Esta capa es muy similar a la anterior, ya que también se trata de definir las interfaces de las entidades. Su función es permitir que las clases concretas de las entidades en la capa "Entities" implementen las propiedades y métodos necesarios sin incluir lógica de negocio. Las interfaces actúan como un contrato entre las clases que definen las entidades y las clases que las manipulan en otras capas del proyecto.

G) Settings: Esta clase se encarga de obtener las configuraciones del archivo "appsettings" de manera dinámica. Su nomenclatura es "Cfg", y más detalles se pueden obtener viendo el código. Esta clase es fundamental para manejar configuraciones de manera centralizada y flexible.

H) GuideStructureAPI (Solución del Proyecto): Esta capa es donde se manejan los controladores. Es importante señalar que los controladores están protegidos mediante un sistema de autenticación basado en "BaseAuthenticator", integrado en .NET 6, lo que garantiza la seguridad de las operaciones en el proyecto.

Este enfoque en la estructura del proyecto y las capas de programación no solo tiene como objetivo estandarizar el desarrollo, sino también crear un código limpio, mantenible y escalable. Cada capa tiene su propósito y debe mantenerse enfocada en una única responsabilidad. Este tipo de arquitectura no solo mejora la calidad del código, sino que también facilita la colaboración en equipo, ya que cada parte del sistema tiene bien definida su función. Al seguir estas buenas prácticas, se garantiza que el sistema sea flexible y capaz de adaptarse a nuevos requisitos sin comprometer su estabilidad. Esta es mi forma de trabajar: un enfoque metódico y estructurado, basado en principios sólidos de diseño y buenas prácticas de desarrollo de software. Aunque este código es solo el inicio de un proyecto, estoy completamente dispuesto a mejorar mis técnicas de programación a medida que adquiero más experiencia y aprendo de nuevas tecnologías. A lo largo del tiempo, este código seguirá creciendo y evolucionando, con la integración de nuevas herramientas y tecnologías que optimicen su funcionamiento. Entre las mejoras que se integrarán, se encuentran patrones de diseño más avanzados, implementaciones con Crystal Reports y Power BI, entre otros servicios, lo que permitirá mejorar la visualización de datos y la capacidad de análisis en el futuro. Este proceso de mejora continua es fundamental para asegurar que el sistema esté a la vanguardia y sea capaz de satisfacer las necesidades cambiantes de los usuarios y de la empresa. Además, se está trabajando en la integración de un sistema de envío de correos electrónicos que permitirá automatizar la comunicación con los usuarios y facilitar tareas como el registro, la recuperación de contraseñas y notificaciones de eventos. Esta funcionalidad, que formará parte de futuras implementaciones, contribuirá a mejorar la experiencia del usuario y la eficiencia operativa del sistema.

Cabe mencionar que actualmente el código está experimentando un pequeño error relacionado con la integración del contexto mediante Scaffold, y se está trabajando activamente para solucionar este inconveniente. Este detalle será corregido en las próximas versiones, garantizando una integración más fluida y optimizada.

****************************************************************************************************************************************************************************************************************************************************************************
English:
****************************************************************************************************************************************************************************************************************************************************************************
My name is José Andrés Alvarado Matamoros, and I have approximately 5 to 6 years of experience as a Software Developer. I am currently an advanced student in the Systems Engineering program at Universidad Fidélitas. This project has been developed using ASP.NET Core Web API technology with the .NET 6 framework. It represents a guide I have started developing using the C# programming language with the goal of standardizing programming structures for future projects. This approach takes into account principles such as single responsibility, code reuse, class standardization through naming conventions, and the use of a well-defined layered architecture.

Throughout this document, each layer will be explained in detail, along with the purpose behind them. Additionally, I will discuss the classes, methods, and some properties.

Without further ado, the project is divided into the following programming layers:

A) BusinessLogic: This layer is responsible for carrying out all functions related to the business logic required by the company. It is important to highlight that current and future classes should be created using the following naming convention: ClassName + BL Suffix. For example, if we want to create a class called "Inventory", following this convention, the class should be named "InventoryBL" using PascalCase. It is essential to note that the only valid method names in our classes should be representative, and to standardize this, method names should be defined as "Get", "Save", "Delete", "Update", and, in exceptional cases, "Process" for methods involving a flow that includes one or more basic methods. Another point to consider is that in the business logic layer, code exceptions should be handled. No "try-catch" definitions should be found in any other classes.

B) BusinessLogicInterface: This layer is responsible for creating programming interfaces, which are essential for organizing and structuring the code. Interfaces act as a contract that defines the methods a class must implement, ensuring that the system behaves consistently. They also provide flexibility, allowing functionalities to be changed or added without affecting the rest of the system. Furthermore, they facilitate teamwork by enabling developers to work on different parts of the project without depending on internal details. In short, interfaces are crucial for maintaining clean, maintainable, and adaptable code. The naming convention should follow the same structure as the BusinessLogic layer, but with the addition of an uppercase "I" at the beginning, such as "IInventoryBL". It is important to emphasize that no business logic should be developed in this layer, only the skeleton that specific classes in the BusinessLogic layer will use.

C) DataAccess: This layer is responsible for handling data access logic, such as interacting with databases or other data managers. It is important to emphasize that no business logic should be developed in this layer; only code related to database manipulation should be included, whether through LINQ or Entity Framework. The naming convention for this layer follows the same structure as the previous layer, using the suffix "DA". For example, the class should be named "InventoryDA" using PascalCase. In this layer, no "try-catch" definitions should be found, and the same rules for method names should apply, using "Get", "Save", "Update", "Delete", and, when necessary, "Process" for methods involving multiple basic methods.

D) DataAccessInterfaces: This layer is responsible for defining the corresponding interfaces for data access. Like the BusinessLogic interfaces, these interfaces act as contracts that specify which methods must be implemented by the classes interacting with the database. No business logic should be written in this layer, only the necessary interfaces to ensure the data access classes in the "DataAccess" layer can implement their functionality correctly.

E) Entities: This class contains the different entities of the project, which represent the system's objects. Only the entities, their "Get" and "Set" methods, and the corresponding data types should be defined here. The naming convention for these classes follows the pattern "ClassNameDTO". For example, if we are working with the "Inventory" entity, the class should be called "InventoryDTO". The purpose of this class is to represent the data structures that will be manipulated by other layers.

F) EntitiesInterfaces: This layer is very similar to the previous one, as it defines the interfaces for the entities. Its role is to allow the concrete entity classes in the "Entities" layer to implement the necessary properties and methods without including business logic. The interfaces act as a contract between the classes defining the entities and the classes manipulating them in other layers of the project.

G) Settings: This class is responsible for dynamically retrieving configuration settings from the "appsettings" file. Its naming convention is "Cfg", and more details can be found by reviewing the code. This class is essential for managing configurations in a centralized and flexible manner.

H) GuideStructureAPI (Project Solution): This layer handles the controllers. It is important to note that the controllers are secured with an authentication system based on "BaseAuthenticator", integrated into .NET 6, ensuring the security of the operations in the project.

This approach to the project structure and programming layers not only aims to standardize development but also to create clean, maintainable, and scalable code. Each layer has its purpose and should remain focused on a single responsibility. This type of architecture not only improves code quality but also facilitates team collaboration, as each part of the system has a well-defined function. By following these best practices, it ensures that the system is flexible and can adapt to new requirements without compromising stability. This is my way of working: a methodical and structured approach based on solid design principles and good software development practices. Although this code is just the beginning of a project, I am fully committed to improving my programming techniques as I gain more experience and learn new technologies. Over time, this code will continue to grow and evolve, incorporating new tools and technologies that optimize its functionality. Among the improvements that will be integrated are more advanced design patterns, implementations with Crystal Reports and Power BI, among other services, which will enhance data visualization and analytical capabilities in the future. This continuous improvement process is essential to ensure the system remains cutting-edge and is capable of meeting the changing needs of users and the company. Additionally, a system for sending emails is being integrated, which will automate communication with users and facilitate tasks such as registration, password recovery, and event notifications. This functionality, which will be part of future implementations, will help improve the user experience and the system's operational efficiency.

It is also worth mentioning that the code is currently experiencing a small bug related to the integration of the context through Scaffold, and active work is being done to resolve this issue. This will be addressed in upcoming versions, ensuring a smoother and more optimized integration.
